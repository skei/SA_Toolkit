#ifndef sat_mac_timer_included
#define sat_mac_timer_included
//----------------------------------------------------------------------

// -lrt

#include <dispatch/dispatch.h>

//#include <sys/time.h>
//#include <errno.h>      // errno


//#include "base/utils/sat_math.h"
#include "base/system/sat_time.h"

//----------------------------------------------------------------------

class SAT_Timer;

class SAT_TimerListener {
public:
  virtual void on_timerListener_callback(SAT_Timer* ATimer, double ADelta) {}
  virtual ~SAT_TimerListener() {}
};

//----------------------------------------------------------------------

//static void sat_timer_callback(sigval val) {
//  //SAT_TimerListener* listener = (SAT_TimerListener*)val.sival_ptr;
//  //if (listener) listener->on_timerCallback(val.sival_int);
//  SAT_Timer* timer = (SAT_Timer*)val.sival_ptr;
//  if (timer) {
//    timer->on_timer();
//    //if (listener) listener->on_timerCallback(val.sival_int);
//  }
//}

//----------------------------------------------------------------------
//
//
//
//----------------------------------------------------------------------

class SAT_Timer {

//------------------------------
private:
//------------------------------

  //friend
  //static void sat_timer_callback(sigval val);

  static void sat_timer_callback(sigval val) {
    //SAT_TimerListener* listener = (SAT_TimerListener*)val.sival_ptr;
    //if (listener) listener->on_timerCallback(val.sival_int);
    SAT_Timer* timer = (SAT_Timer*)val.sival_ptr;
    if (timer) {
      timer->on_timer();
      //if (listener) listener->on_timerCallback(val.sival_int);
    }
  }

//------------------------------
private:
//------------------------------

  sigevent            MSigEvent       = {};
  dispatch_source_t   MTimer          = nullptr;
  // dispatch_time_t     MTimerSpec      = {};  // not used at all currently
  std::atomic<bool>   MIsRunning      {false};
  SAT_TimerListener*  MTimerListener  = nullptr;

  double              MPrevTime       = 0.0;

//------------------------------
public:
//------------------------------

  SAT_Timer(SAT_TimerListener* AListener/*, void* AUserPtr*/) {

    MTimerListener = AListener;
    MIsRunning = false;

    MSigEvent.sigev_notify            = SIGEV_THREAD;
    MSigEvent.sigev_notify_function   = sat_timer_callback;
    MSigEvent.sigev_notify_attributes = nullptr;
    MSigEvent.sigev_value.sival_ptr   = this;//AListener;
    //int res =
    // timer_create(CLOCK_REALTIME, &MSigEvent, &MTimer);
    MTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());

    //SAT_Print("MTimer %i\n",MTimer);
    /*if (res == -1) {
      switch(errno) {
        case EAGAIN:
          SAT_Print("timer_create error: Temporary error during kernel allocation of timer structures.\n");
          break;
        case EINVAL:
          SAT_Print("timer_create error: Clock ID, sigev_notify, sigev_signo, or sigev_notify_thread_id is invalid.\n");
          break;
        case ENOMEM:
          SAT_Print("timer_create error: Could not allocate memory.\n");
          break;
      }
    }*/
  }

  //----------

  // timer_delete() deletes the timer whose ID is given in timerid.  If
  // the timer was armed at the time of this call, it is disarmed before
  // being deleted.  The treatment of any pending signal generated by the
  // deleted timer is unspecified.

  ~SAT_Timer() {
    if (MTimer) {
      dispatch_source_cancel(MTimer);
      dispatch_release(MTimer); // ARC doesn't manage GCD objects, so we release it manually
    }
  }

//------------------------------
public:
//------------------------------

  bool isRunning() {
    return MIsRunning;
  }

  //----------

  void start(float ms, bool oneshot=false) {
    if (!MIsRunning) {
      float s = ms * 0.001f;
      float sec = floorf(s);// SAT_Trunc(s);
      float nsec = (s-sec) * 1000000000; // 1000000.0f * (sec - SAT_Fract(s));
      time_t isec = sec;
      long insec = nsec;
      //SAT_Print("s %.4f sec %.4f nsec %.4f isec %i insec %i\n",s,sec,nsec,isec,insec);

      // Calculate the interval in nanoseconds
      uint64_t interval_ns = static_cast<uint64_t>(ms * NSEC_PER_MSEC);

      // Create a dispatch time for the initial fire time
      dispatch_time_t start_time = dispatch_time(DISPATCH_TIME_NOW, interval_ns);

      if (oneshot) {
        dispatch_after(start_time, dispatch_get_main_queue(), ^{
            if (MTimerListener) {
                double time = SAT_GetTime();
                double delta = time - MPrevTime;
                MPrevTime = time;
                MTimerListener->on_timerListener_callback(this, delta);
            }
        });
      }
      else {
        dispatch_source_t MTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());
        dispatch_source_set_timer(MTimer, start_time, interval_ns, 0);
        dispatch_source_set_event_handler(MTimer, ^{
          if (MTimerListener) {
              double time = SAT_GetTime();
              double delta = time - MPrevTime;
              MPrevTime = time;
              MTimerListener->on_timerListener_callback(this, delta);
          }
        });
        dispatch_resume(MTimer);
      }
      dispatch_source_set_timer(MTimer, start_time, interval_ns, 0);
      //int res =
      /*if (res == -1) {
        switch(errno) {
          case EFAULT:
            SAT_Print("timer_settime error: new_value, old_value, or curr_value is not a valid pointer.\n");
            break;
          //case EINVAL:
          //  SAT_Print("timer_settime error: timerid is invalid.\n");
          //  break;
          case EINVAL:
            SAT_Print("timer_settime: new_value.it_value is negative; or new_value.it_value.tv_nsec is negative or greater than 999,999,999.\n");
            break;
        }
      }*/
      MIsRunning = true;
      MPrevTime = SAT_GetTime();
    }
  }

  //----------

  // If new_value->it_value specifies a nonzero value (i.e., either sub‐
  // field is nonzero), then timer_settime() arms (starts) the timer, set‐
  // ting it to initially expire at the given time.  (If the timer was
  // already armed, then the previous settings are overwritten.)  If
  // new_value->it_value specifies a zero value (i.e., both subfields are
  // zero), then the timer is disarmed.

  void stop() {
    if (MIsRunning) {
      MIsRunning = false;
      if (MTimer) {
        dispatch_source_cancel(MTimer);
      }
      //if (res != 0) { SAT_Print("error stopping timer\n"); }
    //  MIsRunning = false;
    }
  }

  //----------

  void on_timer() {
    double time = SAT_GetTime();//MS();
    double delta = time - MPrevTime;
    //SAT_PRINT("delta %.3f\n",delta);
    if (MTimerListener && MIsRunning) MTimerListener->on_timerListener_callback(this,delta);
    MPrevTime = time;
  }

};

//----------------------------------------------------------------------
#endif

